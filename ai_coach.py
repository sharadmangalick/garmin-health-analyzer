"""AI Coach - Claude integration for personalized training plan generation.

This module provides two modes of operation:
1. Claude Code Mode: Prepares context for Claude Code to generate plans directly
2. API Mode: Uses Anthropic API directly (requires ANTHROPIC_API_KEY)

For enterprise users without API keys, use Claude Code to orchestrate the workflow.
"""

import os
import json
from datetime import date, datetime
from pathlib import Path
from typing import Optional

from user_config import UserConfig


class AICoach:
    """Uses Claude AI to generate personalized training plans."""

    def __init__(self, api_key: Optional[str] = None, use_api: bool = True):
        """
        Initialize AICoach.

        Args:
            api_key: Anthropic API key (optional for Claude Code mode)
            use_api: If False, only prepares context for Claude Code to use
        """
        self.api_key = api_key or os.getenv("ANTHROPIC_API_KEY")
        self.use_api = use_api and bool(self.api_key)
        self.client = None

        if self.use_api:
            from anthropic import Anthropic
            self.client = Anthropic(api_key=self.api_key)

    def generate_training_plan(
        self,
        user_config: UserConfig,
        analysis_results: dict,
        recent_activities: list = None
    ) -> dict:
        """
        Generate a personalized weekly training plan using Claude.

        Args:
            user_config: User profile with goals and preferences
            analysis_results: Health analysis from GarminDataAnalyzer
            recent_activities: List of recent training activities

        Returns:
            Dictionary containing training plan and coaching notes
        """
        # Build the prompt with all context
        prompt = self._build_prompt(user_config, analysis_results, recent_activities)

        if not self.use_api:
            # Claude Code mode - save context and return placeholder
            # The actual plan will be generated by Claude Code
            raise NotImplementedError(
                "No API key available. Use prepare_context() to save context for Claude Code, "
                "then have Claude Code generate the plan."
            )

        # Call Claude API
        response = self.client.messages.create(
            model="claude-sonnet-4-20250514",
            max_tokens=2000,
            messages=[
                {
                    "role": "user",
                    "content": prompt
                }
            ],
            system=self._get_system_prompt()
        )

        # Parse the response
        response_text = response.content[0].text
        return self._parse_response(response_text)

    def prepare_context(
        self,
        user_config: UserConfig,
        analysis_results: dict,
        recent_activities: list = None,
        output_path: Optional[Path] = None
    ) -> Path:
        """
        Prepare and save context for Claude Code to generate a training plan.

        This is used when no API key is available. Claude Code can then read
        this context file and generate the plan directly.

        Args:
            user_config: User profile with goals and preferences
            analysis_results: Health analysis from GarminDataAnalyzer
            recent_activities: List of recent training activities
            output_path: Where to save the context file

        Returns:
            Path to the saved context file
        """
        from config import config

        if output_path is None:
            output_path = config.data_dir / "ai_context.json"

        prompt = self._build_prompt(user_config, analysis_results, recent_activities)

        context = {
            "system_prompt": self._get_system_prompt(),
            "user_prompt": prompt,
            "user_config": user_config.to_dict(),
            "created_at": datetime.now().isoformat(),
            "expected_output_format": self._get_output_format_spec()
        }

        output_path.parent.mkdir(parents=True, exist_ok=True)
        with open(output_path, 'w') as f:
            json.dump(context, f, indent=2)

        return output_path

    def _get_output_format_spec(self) -> dict:
        """Return the expected JSON output format specification."""
        return {
            "week_summary": {
                "total_miles": "number",
                "training_phase": "base|build|peak|taper|race_week",
                "focus": "string"
            },
            "daily_plan": [
                {
                    "day": "Monday|Tuesday|...",
                    "workout_type": "easy|tempo|intervals|long_run|recovery|rest|cross_train",
                    "title": "string",
                    "distance_miles": "number or null",
                    "description": "string",
                    "notes": "string (optional)"
                }
            ],
            "coaching_notes": ["string"],
            "recovery_recommendations": ["string"]
        }

    def _get_system_prompt(self) -> str:
        """Return the system prompt for the AI coach."""
        return """You are an expert running coach with deep knowledge of marathon training,
exercise physiology, and recovery science. You create personalized training plans based on:
- The athlete's current fitness level and health metrics
- Their race goal and timeline
- Recovery indicators from wearable data (resting HR, Body Battery, sleep, stress)
- Training load and recent activities

Your plans should be:
- Specific (exact distances, paces, and effort levels)
- Adaptive (responding to recovery metrics)
- Balanced (mixing easy runs, tempo work, intervals, and long runs)
- Safe (respecting fatigue indicators)

Always respond with valid JSON in the exact format specified."""

    def _build_prompt(
        self,
        user_config: UserConfig,
        analysis_results: dict,
        recent_activities: list = None
    ) -> str:
        """Build the prompt for Claude with all relevant context."""

        user_info = user_config.to_dict()

        # Extract key health metrics
        rhr = analysis_results.get('resting_hr', {})
        bb = analysis_results.get('body_battery', {})
        sleep = analysis_results.get('sleep', {})
        stress = analysis_results.get('stress', {})
        vo2max = analysis_results.get('vo2max', {})

        health_summary = {
            "resting_hr": {
                "current": rhr.get('current'),
                "baseline": rhr.get('baseline'),
                "trend": rhr.get('trend'),
                "status": rhr.get('status')
            } if rhr.get('available') else None,
            "body_battery": {
                "current_wake": bb.get('current_wake'),
                "baseline_wake": bb.get('baseline_wake'),
                "trend": bb.get('trend'),
                "status": bb.get('status')
            } if bb.get('available') else None,
            "sleep": {
                "avg_hours": sleep.get('avg_hours'),
                "under_6h_pct": sleep.get('under_6h_pct'),
                "status": sleep.get('status')
            } if sleep.get('available') else None,
            "stress": {
                "avg": stress.get('avg'),
                "high_stress_pct": stress.get('high_stress_pct'),
                "status": stress.get('status')
            } if stress.get('available') else None,
            "vo2max": {
                "current": vo2max.get('current'),
                "fitness_level": vo2max.get('fitness_level')
            } if vo2max.get('available') else None
        }

        # Format recent activities
        activities_summary = []
        if recent_activities:
            for activity in recent_activities[:10]:  # Last 10 activities
                act_type = activity.get('activityType', {}).get('typeKey', 'unknown')
                distance = activity.get('distance', 0) / 1000  # Convert to km
                duration = activity.get('duration', 0) / 60  # Convert to minutes
                avg_hr = activity.get('averageHR', 'N/A')
                activity_date = activity.get('startTimeLocal', '')[:10]

                activities_summary.append({
                    "date": activity_date,
                    "type": act_type,
                    "distance_km": round(distance, 1),
                    "duration_min": round(duration, 0),
                    "avg_hr": avg_hr
                })

        prompt = f"""Based on the following athlete profile and health data, create a personalized training plan for the upcoming week.

## ATHLETE PROFILE
- Name: {user_info['name']}
- Goal: {user_info['goal_target']} {user_info['goal_type']}
- Race Date: {user_info['goal_date']}
- Weeks Until Race: {user_info['weeks_until_race']}
- Training Phase: {user_info['training_phase']}
- Target Pace: {user_info['target_pace']} per mile
- Current Weekly Mileage: {user_info['current_weekly_mileage']} miles
- Experience Level: {user_info['experience_level']}
- Preferred Long Run Day: {user_info['preferred_long_run_day']}

## HEALTH METRICS (from Garmin data)
{json.dumps(health_summary, indent=2)}

## RECENT ACTIVITIES
{json.dumps(activities_summary, indent=2) if activities_summary else "No recent activity data available"}

## INSTRUCTIONS
Create a 7-day training plan. Consider:
1. The athlete's recovery status (RHR trend, Body Battery, sleep quality)
2. Weeks remaining until the race (adjust intensity/volume for training phase)
3. Recent training load (avoid overtraining)
4. Any concerning health indicators

Respond with ONLY valid JSON in this exact format:
{{
    "week_summary": {{
        "total_miles": <number>,
        "training_phase": "<base|build|peak|taper|race_week>",
        "focus": "<brief description of week's focus>"
    }},
    "daily_plan": [
        {{
            "day": "Monday",
            "workout_type": "<easy|tempo|intervals|long_run|recovery|rest|cross_train>",
            "title": "<brief title>",
            "distance_miles": <number or null>,
            "description": "<detailed workout description with paces/zones>",
            "notes": "<optional coaching notes>"
        }},
        ... (all 7 days)
    ],
    "coaching_notes": [
        "<insight based on health data>",
        "<insight based on training phase>",
        "<key workout priority for the week>"
    ],
    "recovery_recommendations": [
        "<specific recommendation if metrics indicate fatigue>"
    ]
}}"""

        return prompt

    def _parse_response(self, response_text: str) -> dict:
        """Parse Claude's response into structured data."""
        # Try to extract JSON from the response
        try:
            # Look for JSON block
            if "```json" in response_text:
                json_start = response_text.find("```json") + 7
                json_end = response_text.find("```", json_start)
                json_text = response_text[json_start:json_end].strip()
            elif "```" in response_text:
                json_start = response_text.find("```") + 3
                json_end = response_text.find("```", json_start)
                json_text = response_text[json_start:json_end].strip()
            else:
                # Assume entire response is JSON
                json_text = response_text.strip()

            return json.loads(json_text)

        except json.JSONDecodeError as e:
            # Return a fallback structure if parsing fails
            return {
                "error": "Failed to parse AI response",
                "raw_response": response_text,
                "week_summary": {
                    "total_miles": 0,
                    "training_phase": "unknown",
                    "focus": "Error generating plan"
                },
                "daily_plan": [],
                "coaching_notes": ["Error: Could not generate training plan. Please try again."],
                "recovery_recommendations": []
            }

    def get_quick_advice(
        self,
        user_config: UserConfig,
        analysis_results: dict,
        question: str
    ) -> str:
        """
        Get quick coaching advice for a specific question.

        Args:
            user_config: User profile
            analysis_results: Health analysis data
            question: The specific question to answer

        Returns:
            String with coaching advice
        """
        user_info = user_config.to_dict()

        prompt = f"""You are a running coach. Based on this athlete's profile:
- Goal: {user_info['goal_target']} {user_info['goal_type']} on {user_info['goal_date']}
- Weeks until race: {user_info['weeks_until_race']}
- Training phase: {user_info['training_phase']}

Answer this question concisely (2-3 sentences max):
{question}"""

        response = self.client.messages.create(
            model="claude-sonnet-4-20250514",
            max_tokens=300,
            messages=[{"role": "user", "content": prompt}]
        )

        return response.content[0].text
